sprintf implementation reused from land maker

format support:

flag 01: ?
flag 02: pad with 0
flag 04: left align
flag 08: has .
flag 10: add + prefix
flag 20: add space prefix on positives
flag 40: add 0x/0(/0b?) prefix
flag 80: short argument (h)
flag 8000: has a second .

flag 8000

i think this printf has a form like %a.b.c
where a is read into D4, b into D5, c into local_6
flag 8000 says whether to use local_6
flag 08 says whether to use D5



flags (continue sequence)

space - set flag $20
# - set flag $40
* - reads a signed short arg into either:
 - D4 (if flag 08 unset) - toggles flag 04 if non-positive
 - D5 (if flag 08 set and flag 8000 unset)
 - local_6 (if flag 08 set and flag 8000 set)
 also ensures the value is non-negative
+ - sets flag 10
- - sets flag 04
. - sets flag 08. if it wasn't already set, sets D5=0.
 if it was already set, sets flag 8000, and sets local_6=0 if that wasn't already set
0 - sets flag 02
1-9 - reads a number from the format string
 if flag 08 is unset, sets D4
 if flag 08 is set and flag 8000 is unset, sets D5
 if flag 08 is set and flag 8000 is set, sets local_6
L - nop
h - treat argument as short (even though they're all longs on the stack) also affects `n`
l - nop



supported flags:

0 - pad to width with zeros instead of spaces
- - left align (pad right side instead of left)
+ - print + prefix on non-negative numbers
space - print space prefix on non negative numbers
 BUG: in %D and %d/%i, the space flag causes it to print a nul after the space
 TODO: fix this by just changing `72 02 43 fa 00 4e` and `72 02 43 fa fe b4` -> `72 01 ...`
# - print base prefix ("0X" on %P/%X, "0x" on %p/%x, "0" on %o. not supported by %b)
h - short mode (not supported by all specifiers)
L - does nothing
l - does nothing

this printf supports 3 numeric arguments: [width][.precision[.maxlength]]
unless otherwise employed (%B and %D), the third numeric argument sets the maximum length of the numerical/string part (not affecting padding or prefixes).
it behaves similarly to the .precision with %s, but truncates from the left instead of the right and affects all specifiers
 e.g. "%8.6.3d" with -1234 prints "-000234 "
 "%.2s" with "abcd" prints "ab", while "%.4.2s" prints "cd"

supported specifiers:

c - character

d/i - signed decimal. does NOT respect `h` flag

n - output the number of characters printed, to a pointer. respects `h` flag (uses move.w or move.l depending on that)

o - octal. respects `h` flag

p - pointer, lowercase. like %08x
P - pointer, uppercase. like %08X

s - string
 if pointer is null, nothing is printed

u - unsigned decimal. respects `h` flag
 
x - hex, lowercase. respects `h` flag
X - hex, uppercase. respects `h` flag

non-standard specifiers:

B - prints binary coded decimal, as decimal, given a pointer to the BCD string.
 the third numeric argument (%..nB) is the number of digits to READ from memory.
 (this length can be odd, in which case the first digit (high nibble of the first byte) is skipped)

D - prints fixed point, as decimal. does NOT respect `h` flag
 third numeric argument is the number of fractional bits (0-28, default 15)
 BUG: if fractional bits is 0 and the argument is -2147483648, 2147483648 is printed instead (without a sign, even if the + or space flags are set)
 (TODO: fix this by moving sprintf_minus to before sprintf_2^31 and then increasing the length of the copy by 1. this requires altering 4 references)

b - binary. respects `h` flag
